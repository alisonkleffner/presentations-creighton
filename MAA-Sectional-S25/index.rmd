---
title: "Visualization and Modeling of Sea Ice Trajectories"
subtitle: "MAA Sectional"
author: "Alison Kleffner"
date: "Department of Mathematics, Creighton University"
output:
  xaringan::moon_reader:
    seal: false
    includes:
      after_body:
        "js-addins.html"
    #mathjax: "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_HTMLorMML"
    css: ["default", "metropolis-fonts", "metropolis" ,"css/modal.css", "css/sizeformat.css"]
    lib_dir: libs
    nature:
      highlightStyle: github
      highlightlines: true
      countIncrementalSlides: true
---
class:title-slide-custom

```{r, child = "style.Rmd"}
```


```{r setup, echo = FALSE, message = FALSE, warning = FALSE}
# Packages
library(emoji)
library(purrr)
library(tidyverse)
library(gridExtra)
library(nullabor)
library(scales)
library(knitr)
library(kableExtra)
library(RefManageR)
library(fontawesome)
library(shiny)
# download_fontawesome()

# References
bib <- ReadBib("bib/thesis.bib", check = FALSE)
ui <- "- "

# R markdown options
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE, 
                      warning = FALSE, 
                      cache = TRUE,
                      dpi = 300)
options(htmltools.dir.version = FALSE)
options(knitr.kable.NA = '')
```

```{r, include = F, eval = T, cache = T}
clean_file_name <- function(x) {
  basename(x) %>% str_remove("\\..*?$") %>% str_remove_all("[^[A-z0-9_]]")
}
img_modal <- function(src, alt = "", id = clean_file_name(src), other = "") {
  
  other_arg <- paste0("'", as.character(other), "'") %>%
    paste(names(other), ., sep = "=") %>%
    paste(collapse = " ")
  
  js <- glue::glue("<script>
        /* Get the modal*/
          var modal{id} = document.getElementById('modal{id}');
        /* Get the image and insert it inside the modal - use its 'alt' text as a caption*/
          var img{id} = document.getElementById('img{id}');
          var modalImg{id} = document.getElementById('imgmodal{id}');
          var captionText{id} = document.getElementById('caption{id}');
          img{id}.onclick = function(){{
            modal{id}.style.display = 'block';
            modalImg{id}.src = this.src;
            captionText{id}.innerHTML = this.alt;
          }}
          /* When the user clicks on the modalImg, close it*/
          modalImg{id}.onclick = function() {{
            modal{id}.style.display = 'none';
          }}
</script>")
  
  html <- glue::glue(
     " <!-- Trigger the Modal -->
<img id='img{id}' src='{src}' alt='{alt}' {other_arg}>
<!-- The Modal -->
<div id='modal{id}' class='modal'>
  <!-- Modal Content (The Image) -->
  <img class='modal-content' id='imgmodal{id}'>
  <!-- Modal Caption (Image Text) -->
  <div id='caption{id}' class='modal-caption'></div>
</div>
"
  )
  write(js, file = "js-addins.html", append = T)
  return(html)
}
# Clean the file out at the start of the compilation
write("", file = "js-addins.html")
```

<br><br><br>
## Visualization of Correlation within Spatial Experimental Plots
#### Alison Kleffner
#### Department of Mathematics, Creighton University
##### `r fa("envelope", fill = "black")` [alisonkleffner@creighton.edu](email.address@creighton.edu)
##### `r fa("home", fill = "black")` [https://alison-kleffner.netlify.app/](https://alison-kleffner.netlify.app/)
##### `r fa("github", fill = "black")` [alisonkleffner](https://github.com/alisonkleffner)
<br><br>
.medium[*Slides: https://alisonkleffner.github.io/presentations-creighton/graphics-group/S24/index.html#1*]

---
class:primary
# Outline

---
class:primary
# Motivation

The rapid development of technology, like global position systems (GPS) and geographic information systems (GIS), has led to a dramatic increase in the amount of spatial and spatio-temporal data collected `r Citep(bib[[c("ansari_spatiotemporal_2020")]])` 

+ This growth has necessitated the development of new techniques to work with this data `r Citep(bib[[c("yuan_review_2017")]])`
+ We focus on environmental applications with multivariate spatial data and trajectory data.

---
class:primary
# Motivation

**Interest**: Discover patterns within the trajectories to help understand their behavior `r  Citep(bib[[c("andrienko_visual_2007")]])` 

**A Method**: Visualization during Exploratory Data Analysis (EDA):  
  + Trajectories are difficult to visualize (messy)
  + Provide insight into the underlying dynamics driving movement.

**Extract Features**: Since trajectories are complex, so we can extract features from the raw data `r Citep(bib[[c("climate-viz")]])` 
  + Can use visualization to motivate feature creation
  + Want to create features that provide a quantitative summary of the movement seen in plots 

**Case Study**: Arctic Sea Ice Crack Detection

???

Of common interest with trajectories is to discover patterns within their movements to help understand the trajectories behavior. One method to help discover these patterns is to visualize the trajectories during exploratory data analysis. These plots tend to messy due to the complexity of trajectories, but they can still provide some insight into the underlying dynamics driving movement. Since trajectories are complex, extracting features form them may make them easier to work within different methods. The features should summarize it's movement. Visualization can be used to motivate the creation of features. For example, Wu et al (2022) developed a method called TPoSTE which created features based on events to separate a boat's trajectory into period of fishing or sailing. For our process, we focus on a case study involving arctic sea ice trajectories.

---
class:primary

# Importance of Arctic Sea Ice Crack Detection

+ Sea ice serves as a barrier between the atmosphere and the ocean
+ Cracks, or leads, may form in the ice pack due to dynamic processes
  - Allows for heat from the ocean to be transferred to the atmosphere `r Citep(bib[[c("schreyer_elastic_2006")]])`. 
  - Accounts for half of the heat flux between the ocean and atmosphere `r Citep(bib[[c("badgley_1961")]])`
+ Previous ice crack detection methods can generally be split into two categories: thermal and deformation. 
  

.center[
```{r ice-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/Ice Chunk.png", alt = " Artice Sea Ice with Crack", other=list(width="40%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]



---
class:primary
# Data

.center[
```{r grid-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/rgps_grid.jpg", alt = "Example of initial grid used to track movement (Peterson & Sulsky, 2011)", other=list(width="25%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

+ Arctic Sea Ice is tracked by NASA's RADARSTAT Geophysical Processor System (RGPS), which uses synthetic aperture radar (SAR) images
+ Each grid cell vertex is assigned an identifier $(j=1,...,n)$ which is used for tracking
+ Set of all trajectories: 

.center[
$\mathcal{G} = \left\{g_1, ..., g_n\right\}$ $\\$
where $g_{j} = \left\{s_{jt} : t \in \mathcal{T}_j\right\}$, $\mathcal{T}_j \subset \left\{t=1...T\right\}$ a collection of time points where $g_j$ is observed $\\$
and ${s_{jt}}$ = $(x_{jt}, y_{jt})$
]

+ For our study region, $n$ = 8811, and $T$ = 22

???

The sea ice trajectories were tracked by NASA's RADARSTATE geophysical processor system (RGPS), which uses sequential synthetic aperture radar images to track the trajectory of point on an ice sheet. On the first day of the study period, a grid is put on the image, where each grid cell vertex is assigned an identifier (j) that is tracked over the study period using feature based and area based tracking. At the end of the study period we have a data set of n trajectories, where each trajectory is a collection of spatial locations at different times. Due to collecting this data with a satellite, not all the trajectories are observed on the same day, so we have a collection of possible times. We focused on the Beaufort region, so we have a total of 8811 trajectories on 22 possible days.

---
class:primary
# Gestalt Principles of Visual Perception

**Identifing Patterns**: Can use the gestalt principles of visual perception to process large amounts of data efficiently. 
+ Explains how humans naturally perceive objects and organize them in groups

.pull-left[
Principle of Similarity: group items that look similar .
  + Trajectories with similar shapes and orientations `r Citep(bib[[c("chalbi_gestalt")]])`
.center[  
```{r law-sim,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/law-sim.png", alt = "Example of gestalt law of similarity", other=list(width="40%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]
].pull-right[
Principle of Common Fate: group objects that share a dynamic behavior
  + Affected by the same underlying processes `r Citep(bib[[c("chalbi_gestalt", "alais-gestalt-1998")]])` 
.center[
```{r law-fate,  results='asis', echo = F, include = T, cache = T, eval = TRUE}

i1 <- img_modal(src = "images/common-fate.png", alt = "Example of gestalt law of common fate", other=list(width="60%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]]

???

Before we look at visualizations of the trajectories used during EDA, I first wanted to talk about an important tool to help extract patterns. The gestalt principles of visual perception helps users process large amounts of data efficiently by explaining how humans naturally perceive objects and organize them into groups. There are multiple, but we are going to focus on three here. The principle of similarity says that people tend to group items that look similar. So we organize trajectories with similar shapes and orientations into groups. Second is the principle of common fate used with animated graphics. This principle says that people group objects that share a dynamic behavior, like a flock of birds, as this means those objects are potentially affected by the same underlying processes. 

---
class:primary

# Static Trajectory Plot


+ Line segments, with the direction of each trajectory denoted by an arrow at the end `r Citep(bib[[c("andrienko_supporting_2000")]])` 
  - Shows the displacement and direction over time.
+ This plot violates several guidelines for effective visualization, making it
unsuitable for presentation.
  - However, the principle of similarity helps a viewer easily group trajectories that look to move with a similar form in the same direction over time

.center[
```{r traj-pic,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/traj_plot.png", alt = "Plot of id trajectories to show movement and directiction of movement", other=list(width="55%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

???

First, we created a static plot of all of our trajectories, which connected each observed location of a trajectory with a line segment, and an arrow was added to the end to show the ending direction of movement. So this plot shows the displacement and direction of each trajectory over time.This plot is messy and violates several principles of effective graphics. For example, it's cluttered (trajectories on top of each other), and the color has no meaning (was just used to help visually differentiate the different trajectories better). The coloring is potentially problematic due to the principle of similarity, a user may group all similarly colored trajectories and try to derive a relationship which would be inaccurate. However, using the principle of similarity is also helpful as we can see group of trajectories that look to move with a similar form in the same direction. These groups tend to occur in contiguous patches and stick out even though the plot is kind of a mess. So we can make an assumption, that the underlying process causing the sea ice to move changes based on the location. 

---
class:primary
# Animated Trajectory Plot

[Link](https://alisonkleffner.github.io/presentations-creighton/MAA-Sectional-S25/traj.html)

+ Shows the incremental progress of each trajectory over time
  - Plot the new location at each time step and connect the new observation with the previous through a line segment. 
+ New information:
  - See a trajectory speeding up or slowing down through the length of the added line segments. 
  - Associate a movement with a particular day
+ Using gestalt principle of common fate
  - Trajectories moving with a similar velocity in contiguous patches.

???

Another drawback of the static trajectory plot is the inability to associated different movements with a specific time. So don't learn things related to specific times, just total time. So we can create an animation of our movement. We chose to use animation as Griffin et al (2006) found that animated plots allows users to identify moving clusters easier than multiple juxtaposed static plots. In our animated plot, we showed the incremental process of each trajectory on each day by adding the movement for a day, represented by a line segment, to the previous days movement. Now we can see the trajectory speeding up and slowing down based on the length of added line segments. Further, we can associate a movement with a particular day, like what day a trajectory changes direction. Here we can use the principle of common fate to group trajectories moving with a similar velocity (direction/speed), which once again seems to occur in contiguous patches.

---
class:primary

# Deriving Numerical Features: Bounding Box

+ We create a bounding box around for each trajectory to represent it's movement
+ Bounding Box Features:
  - Length travel in x/y between the minimum and maximum location 
.center[
( $x_{max} - x_{min}$ and $y_{max} - y_{min}$)]
  - Length travel in x/y between latest and earliest observation 
  .center[
  ( $x_{2} - x_{1}$ and $y_{2} - y_{1}$)]
  - Angle of movement (direction)

.center[
.pull-left[
```{r bb-pic1,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/bb_1.png", alt = "Points used to Develop Bounding Box 1", other=list(width="75%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
].pull-right[

```{r bb-pic2,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/bb_2.png", alt = "Points used to Develop Bounding Box 2", other=list(width="55%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()
```

]
]

???

After visually exploring the data during exploratory data analysis, we wanted to derive numerical features based on the visualizations. This was done by creating essentially a bounding box around each trajectory, which represents its movement over time. We can then calculate different features from this bounding box. First, we can find the distance between the maximum and minimum coordinates (total displacement). Second, this value may not always represent the first and last day of the time frame, so we also found the different between the latest and earliest observation (displacement in time). Finally, using the displacement in time, we found the angle that the trajectory moved over the time frame.


---
class:primary
# Deriving Numerical Features: Wiggle

.center[
```{r wiggle,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/wiggle.png", alt = "Wiggle Calculation", other=list(width="50%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

+ To determine the amount of “wiggle”, we estimated the total length of the trajectory (arc length).
  - Find the distance between each set of two connected
points (yellow lines).
  - Add all the calculated distances to estimate the total length of the trajectory.
  - Trajectories with a higher total length are "wigglier"

???

Next, besides the bounding box, we wanted to derive a numerical assessment of "wiggle", as this is something that can be seen but may be hard to quantify. How I began to think through this was by imaging we pulled a trajectory so that it was straight. Trajectories with more wiggle would be longer that those with less wiggle. Since each trajectory consists of observed points connected by line segments, I found the length of each line segment and atted them all together (estimate of act length). So the trajectories with a higher total length are wigglier.

---
class:primary

#Clustering with K-Means

+ Bounding Box features were used as input into K-Means clustering, which partitions n observations into k clusters.
+ K-Means Clustering `r Citep(bib[[c("steinley_kmeans_2006")]])`
  - All observations must belong to a cluster and each cluster, k, must have at least one observation
  - Iterative Procedure 
  - Minimize squared Euclidean distance between an observation and the centroid vector of a cluster
  - Centroid vector found by averaging the features of each cluster member


---
class:primary
# Feature Selection

+ Not all characteristics of a trajectory are simultaneously relevant `r Citep(bib[[c("rinzivillo_visuallydriven_2008")]])`
+ Clustering algorithm to assign trajectories to groups of similar
movements 
+ No label information to help evaluate feature importance, used visualization to make judgements `r Citep(bib[[c("li-features")]])`.
  - Redundant:  adding it to the clustering algorithm, while
holding the other variables constant, does not change the assigned clusters.
  - Relevance: help with cluster continuity

.center[
```{r feat-comp,  results='asis', echo = F, include = T, cache = T, eval = TRUE}


i1 <- img_modal(src = "images/feature-comparison4.png", alt = "Subsets of Clusters to Determine Relevant Features", other=list(width="60%"))

c(str_split(i1, "\\n", simplify = T)[1:2],
  str_split(i1, "\\n", simplify = T)[3:9]
  ) %>% paste(collapse = "\n") %>% cat()

```
]

???

Finally, not all characteristics of a trajectory are simultaneously relevant when analyzing trajectories, so we wanted to employ feature selection to assess relevancy. Since we could see the movement occurring in contiguous patches, we applied a clustering algorithm to find this groups of similar movements. So we have no label information (don't know true trajectories), we used  visualization to make judgements. So assigned each cluster a color, and output a single point of each trajectory with the assigned color onto a map. We classified redundant features as adding a feature to the clustering does not change the assigned cluster. Further, we wanted our features to help create continguous clusters. Did not text all possible subsets of features, just some I thought was relevant.  (Explain process). Plot 4 is the features selected.


---
class:primary
# References
<font size="1.5">
```{r, print_refs1, results='asis', echo=FALSE, warning=FALSE, message=FALSE}
print(bib[[c("ansari_spatiotemporal_2020", "yuan_review_2017")]], 
      .opts = list(check.entries = FALSE, style = "html", bib.style = "authoryear")
      )
```
</font>

---
class:inverse
<br>
<br>
<br>
.center[
# Questions?
<br>
<br>
`r fa("envelope", fill = "white")` **alisonkleffner@creighton.edu**
`r fa("github", fill = "white")` **alisonkleffner**
]
